{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django API Forms \u00b6 Django Forms approach in validation of request payload (especially for content type like JSON or MessagePack ) without HTML front-end. Motivation \u00b6 Main idea was to create a simple and declarative way to specify format of expecting request with ability to validate them. Firstly I tried to use Django Forms to validate my API request (I use pure Django in my APIs). I have encountered a problem with nesting my requests without huge boilerplate. Also, the whole HTML thing was pretty useless in my RESTful APIs. I wanted something to: define my requests as object ( Form ) pass the request to my defined object ( form = Form.create_from_request(request) ) validate my request form.is_valid() extract data form.clean_data property I wanted to keep: friendly declarative Django syntax ( DeclarativeFieldsMetaclass is beautiful) Django Validators ValidationError So I decided to create simple Python package to cover all my expectations. Community examples \u00b6 django_api_forms_modelchoicefield_example : Example usage of the ModelChoiceField with Django API Forms created by pawl Tests \u00b6 # install all dependencies poetry install # run the tests poetry run pytest","title":"Home"},{"location":"#django-api-forms","text":"Django Forms approach in validation of request payload (especially for content type like JSON or MessagePack ) without HTML front-end.","title":"Django API Forms"},{"location":"#motivation","text":"Main idea was to create a simple and declarative way to specify format of expecting request with ability to validate them. Firstly I tried to use Django Forms to validate my API request (I use pure Django in my APIs). I have encountered a problem with nesting my requests without huge boilerplate. Also, the whole HTML thing was pretty useless in my RESTful APIs. I wanted something to: define my requests as object ( Form ) pass the request to my defined object ( form = Form.create_from_request(request) ) validate my request form.is_valid() extract data form.clean_data property I wanted to keep: friendly declarative Django syntax ( DeclarativeFieldsMetaclass is beautiful) Django Validators ValidationError So I decided to create simple Python package to cover all my expectations.","title":"Motivation"},{"location":"#community-examples","text":"django_api_forms_modelchoicefield_example : Example usage of the ModelChoiceField with Django API Forms created by pawl","title":"Community examples"},{"location":"#tests","text":"# install all dependencies poetry install # run the tests poetry run pytest","title":"Tests"},{"location":"example/","text":"Example \u00b6 JSON request \u00b6 { \"title\" : \"Unknown Pleasures\" , \"type\" : \"vinyl\" , \"artist\" : { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 }, \"year\" : 1979 , \"songs\" : [ { \"title\" : \"Disorder\" , \"duration\" : \"3:29\" }, { \"title\" : \"Day of the Lords\" , \"duration\" : \"4:48\" , \"metadata\" : { \"_section\" : { \"type\" : \"ID3v2\" , \"offset\" : 0 , \"byteLength\" : 2048 }, \"header\" : { \"majorVersion\" : 3 , \"minorRevision\" : 0 , \"flagsOctet\" : 0 , \"unsynchronisationFlag\" : false , \"extendedHeaderFlag\" : false , \"experimentalIndicatorFlag\" : false , \"size\" : 2038 } } } ], \"metadata\" : { \"created_at\" : \"2019-10-21T18:57:03+0100\" , \"updated_at\" : \"2019-10-21T18:57:03+0100\" } } Python implementation \u00b6 from enum import Enum from django.core.exceptions import ValidationError from django.forms import fields from django_api_forms import FieldList , FormField , FormFieldList , DictionaryField , EnumField , AnyField , Form class AlbumType ( Enum ): CD = 'cd' VINYL = 'vinyl' class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) duration = fields . DurationField ( required = False ) metadata = AnyField ( required = False ) class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) songs = FormFieldList ( form = SongForm ) type = EnumField ( enum = AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def clean_year ( self ): if self . cleaned_data [ 'year' ] == 1992 : raise ValidationError ( \"Year 1992 is forbidden!\" , 'forbidden-value' ) return self . cleaned_data [ 'year' ] def clean ( self ): if ( self . cleaned_data [ 'year' ] == 1998 ) and ( self . cleaned_data [ 'artist' ][ 'name' ] == \"Nirvana\" ): raise ValidationError ( \"Sounds like a bullshit\" , code = 'time-traveling' ) return self . cleaned_data \"\"\" Django view example \"\"\" def create_album ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Process your validation error print ( form . errors ) # Cleaned valid payload payload = form . cleaned_data print ( payload )","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#json-request","text":"{ \"title\" : \"Unknown Pleasures\" , \"type\" : \"vinyl\" , \"artist\" : { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 }, \"year\" : 1979 , \"songs\" : [ { \"title\" : \"Disorder\" , \"duration\" : \"3:29\" }, { \"title\" : \"Day of the Lords\" , \"duration\" : \"4:48\" , \"metadata\" : { \"_section\" : { \"type\" : \"ID3v2\" , \"offset\" : 0 , \"byteLength\" : 2048 }, \"header\" : { \"majorVersion\" : 3 , \"minorRevision\" : 0 , \"flagsOctet\" : 0 , \"unsynchronisationFlag\" : false , \"extendedHeaderFlag\" : false , \"experimentalIndicatorFlag\" : false , \"size\" : 2038 } } } ], \"metadata\" : { \"created_at\" : \"2019-10-21T18:57:03+0100\" , \"updated_at\" : \"2019-10-21T18:57:03+0100\" } }","title":"JSON request"},{"location":"example/#python-implementation","text":"from enum import Enum from django.core.exceptions import ValidationError from django.forms import fields from django_api_forms import FieldList , FormField , FormFieldList , DictionaryField , EnumField , AnyField , Form class AlbumType ( Enum ): CD = 'cd' VINYL = 'vinyl' class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) duration = fields . DurationField ( required = False ) metadata = AnyField ( required = False ) class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) songs = FormFieldList ( form = SongForm ) type = EnumField ( enum = AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def clean_year ( self ): if self . cleaned_data [ 'year' ] == 1992 : raise ValidationError ( \"Year 1992 is forbidden!\" , 'forbidden-value' ) return self . cleaned_data [ 'year' ] def clean ( self ): if ( self . cleaned_data [ 'year' ] == 1998 ) and ( self . cleaned_data [ 'artist' ][ 'name' ] == \"Nirvana\" ): raise ValidationError ( \"Sounds like a bullshit\" , code = 'time-traveling' ) return self . cleaned_data \"\"\" Django view example \"\"\" def create_album ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Process your validation error print ( form . errors ) # Cleaned valid payload payload = form . cleaned_data print ( payload )","title":"Python implementation"},{"location":"fields/","text":"Fields \u00b6 Even if we tried to most of the native Django fields, we had to override some of them to be more fit for RESTful applications. Also we introduced new ones, to cover extra functionality like nested requests. In this section we will explain our intentions and describe their usage. To sum up: You can use Django Form Fields : CharField ChoiceField TypedChoiceField DateField DateTimeField DecimalField DurationField EmailField FilePathField FloatField IntegerField GenericIPAddressField MultipleChoiceField TypedMultipleChoiceField RegexField SlugField TimeField URLField UUIDField ModelChoiceField ModelMultipleChoiceField You can use Django Validators . Fields which are not in the list above were not been tested or been replaced with our customized implementation (or it just doesn't make sense use them in RESTful APIs). BooleanField \u00b6 Normalizes to: A Python True or False value (or None if it's not required) Django BooleanField checks only for False ( false , 0 ) values and everything else is suppose to be True . In my point of view this kind of behaviour it's little bit weird, so we decided to check explicitly for True and False values. If field is required ValidationError is raised or value is normalized as None . Checked values: True : True 'True' 'true' 1 '1' False : False 'False' 'false' 0 '0' Note: We would like to change this behaviour to support only boolean values and rely on deserializers. FieldList \u00b6 This field is used to parse list of primitive values (like strings or numbers). If you want to parse list of object, check FormFieldList . Normalizes to: A Python list Error message keys: not_field , not_list , min_length , max_length Required arguments: field : Instance of a form field representing children Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"numbers\" : [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ] } Python representation from django_api_forms import Form , FieldList from django.forms import fields class FibonacciForm ( Form ): numbers = FieldList ( field = fields . IntegerField ()) FormField \u00b6 Field used for embedded objects represented as another API form. Normalizes to: A Python dictionary Required arguments: form : Type of a nested form JSON example { \"title\" : \"Unknown Pleasures\" , \"year\" : 1979 , \"artist\" : { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } } Python representation from django_api_forms import Form , FormField , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) FormFieldList \u00b6 Field used for embedded objects represented as another API form. Normalizes to: A Python list of dictionaries Error message keys: not_list , min_length , max_length Required arguments: form : Type of a nested form Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"title\" : \"Rock For People\" , \"artists\" : [ { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } ] } Python representation from django_api_forms import Form , FormFieldList , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class FestivalForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artists = FormFieldList ( form = ArtistForm ) EnumField \u00b6 Tip : Django has pretty cool implementation of the enumeration types . Normalizes to: A Python Enum object Error message keys: not_enum , invalid Required arguments: enum : Enum class JSON example { \"title\" : \"Rock For People\" , \"type\" : \"vinyl\" } Python representation from django_api_forms import Form , EnumField from django.forms import fields from django.db.models import TextChoices class AlbumType ( TextChoices ): CD = 'cd' , 'CD' VINYL = 'vinyl' , 'Vinyl' class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) type = EnumField ( enum = AlbumType ) DictionaryField \u00b6 Field created for containing typed value pairs (currently library supports only value validation, see Key validation in DictionaryField ). Normalizes to: A Python dictionary Error message keys: not_dict Required arguments: value_field : Type of a nested form JSON example { \"my_dict\" : { \"b061bb03-1eaa-47d0-948f-3ce1f15bf3bb\" : 2.718 , \"0a8912f0-6c10-4505-bc27-bbb099d2e395\" : 42 } } Python representation from django_api_forms import Form , DictionaryField from django.forms import fields class DictionaryForm ( Form ): my_typed_dict = DictionaryField ( value_field = fields . DecimalField ()) AnyField \u00b6 Field without default validators. Normalizes to: Type according to the chosen request payload parser JSON example { \"singer\" : { \"name\" : \"Johnny\" , \"surname\" : \"Rotten\" , \"age\" : 64 , \"born_at\" : \"1956-01-31\" } } Python representation from django_api_forms import Form , DictionaryField , AnyField class BandForm ( Form ): singer = DictionaryField ( value_field = AnyField ()) FileField \u00b6 This field contains BASE64 encoded file. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime Arguments: max_length : Maximum files size in bytes (optional) mime : List (should be a tuple in future) of allowed mime types (optional - if present, value must be in form of Data URI ) Extra normalised attributes: file_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format) JSON example { \"title\" : \"Disorder\" , \"type\" : \"data:audio/mpeg;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , FileField from django.conf import settings from django.forms import fields class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) audio = FileField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = [ 'audio/mpeg' ]) ImageField \u00b6 This field contains BASE64 encoded image. Depends on Pillow because normalized value contains Image object. Pillow is also used for image validation Image.verify() is called. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime , invalid_image (if Image.verify() failed) Arguments: max_length : Maximum files size in bytes (optional) mime : List (should be a tuple in future) of allowed mime types (optional, value must be in Data URI ) Extra normalised attributes: image_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format). Value is filled using Pillow Image.MIME.get(image.format) ) image_field.clean(payload).image : A Pillow Image object instance JSON example { \"title\" : \"Unknown pleasures\" , \"cover\" : \"data:image/png;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , ImageField from django.conf import settings from django.forms import fields class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) cover = ImageField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = [ 'image/png' ])","title":"Fields"},{"location":"fields/#fields","text":"Even if we tried to most of the native Django fields, we had to override some of them to be more fit for RESTful applications. Also we introduced new ones, to cover extra functionality like nested requests. In this section we will explain our intentions and describe their usage. To sum up: You can use Django Form Fields : CharField ChoiceField TypedChoiceField DateField DateTimeField DecimalField DurationField EmailField FilePathField FloatField IntegerField GenericIPAddressField MultipleChoiceField TypedMultipleChoiceField RegexField SlugField TimeField URLField UUIDField ModelChoiceField ModelMultipleChoiceField You can use Django Validators . Fields which are not in the list above were not been tested or been replaced with our customized implementation (or it just doesn't make sense use them in RESTful APIs).","title":"Fields"},{"location":"fields/#booleanfield","text":"Normalizes to: A Python True or False value (or None if it's not required) Django BooleanField checks only for False ( false , 0 ) values and everything else is suppose to be True . In my point of view this kind of behaviour it's little bit weird, so we decided to check explicitly for True and False values. If field is required ValidationError is raised or value is normalized as None . Checked values: True : True 'True' 'true' 1 '1' False : False 'False' 'false' 0 '0' Note: We would like to change this behaviour to support only boolean values and rely on deserializers.","title":"BooleanField"},{"location":"fields/#fieldlist","text":"This field is used to parse list of primitive values (like strings or numbers). If you want to parse list of object, check FormFieldList . Normalizes to: A Python list Error message keys: not_field , not_list , min_length , max_length Required arguments: field : Instance of a form field representing children Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"numbers\" : [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 ] } Python representation from django_api_forms import Form , FieldList from django.forms import fields class FibonacciForm ( Form ): numbers = FieldList ( field = fields . IntegerField ())","title":"FieldList"},{"location":"fields/#formfield","text":"Field used for embedded objects represented as another API form. Normalizes to: A Python dictionary Required arguments: form : Type of a nested form JSON example { \"title\" : \"Unknown Pleasures\" , \"year\" : 1979 , \"artist\" : { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } } Python representation from django_api_forms import Form , FormField , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm )","title":"FormField"},{"location":"fields/#formfieldlist","text":"Field used for embedded objects represented as another API form. Normalizes to: A Python list of dictionaries Error message keys: not_list , min_length , max_length Required arguments: form : Type of a nested form Optional arguments: min_length : Minimum length of field size as integer max_length : Maximum length of field size as integer JSON example { \"title\" : \"Rock For People\" , \"artists\" : [ { \"name\" : \"Joy Division\" , \"genres\" : [ \"rock\" , \"punk\" ], \"members\" : 4 } ] } Python representation from django_api_forms import Form , FormFieldList , FieldList from django.forms import fields class ArtistForm ( Form ): name = fields . CharField ( required = True , max_length = 100 ) genres = FieldList ( field = fields . CharField ( max_length = 30 )) members = fields . IntegerField () class FestivalForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artists = FormFieldList ( form = ArtistForm )","title":"FormFieldList"},{"location":"fields/#enumfield","text":"Tip : Django has pretty cool implementation of the enumeration types . Normalizes to: A Python Enum object Error message keys: not_enum , invalid Required arguments: enum : Enum class JSON example { \"title\" : \"Rock For People\" , \"type\" : \"vinyl\" } Python representation from django_api_forms import Form , EnumField from django.forms import fields from django.db.models import TextChoices class AlbumType ( TextChoices ): CD = 'cd' , 'CD' VINYL = 'vinyl' , 'Vinyl' class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) type = EnumField ( enum = AlbumType )","title":"EnumField"},{"location":"fields/#dictionaryfield","text":"Field created for containing typed value pairs (currently library supports only value validation, see Key validation in DictionaryField ). Normalizes to: A Python dictionary Error message keys: not_dict Required arguments: value_field : Type of a nested form JSON example { \"my_dict\" : { \"b061bb03-1eaa-47d0-948f-3ce1f15bf3bb\" : 2.718 , \"0a8912f0-6c10-4505-bc27-bbb099d2e395\" : 42 } } Python representation from django_api_forms import Form , DictionaryField from django.forms import fields class DictionaryForm ( Form ): my_typed_dict = DictionaryField ( value_field = fields . DecimalField ())","title":"DictionaryField"},{"location":"fields/#anyfield","text":"Field without default validators. Normalizes to: Type according to the chosen request payload parser JSON example { \"singer\" : { \"name\" : \"Johnny\" , \"surname\" : \"Rotten\" , \"age\" : 64 , \"born_at\" : \"1956-01-31\" } } Python representation from django_api_forms import Form , DictionaryField , AnyField class BandForm ( Form ): singer = DictionaryField ( value_field = AnyField ())","title":"AnyField"},{"location":"fields/#filefield","text":"This field contains BASE64 encoded file. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime Arguments: max_length : Maximum files size in bytes (optional) mime : List (should be a tuple in future) of allowed mime types (optional - if present, value must be in form of Data URI ) Extra normalised attributes: file_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format) JSON example { \"title\" : \"Disorder\" , \"type\" : \"data:audio/mpeg;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , FileField from django.conf import settings from django.forms import fields class SongForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) audio = FileField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = [ 'audio/mpeg' ])","title":"FileField"},{"location":"fields/#imagefield","text":"This field contains BASE64 encoded image. Depends on Pillow because normalized value contains Image object. Pillow is also used for image validation Image.verify() is called. Normalizes to: A Django File object Error message keys: max_length , invalid_uri , invalid_mime , invalid_image (if Image.verify() failed) Arguments: max_length : Maximum files size in bytes (optional) mime : List (should be a tuple in future) of allowed mime types (optional, value must be in Data URI ) Extra normalised attributes: image_field.clean(payload).content_type : Mime type ( str - e.g. audio/mpeg ) of containing file ( None if unable to detect - if payload is not in DATA URI format). Value is filled using Pillow Image.MIME.get(image.format) ) image_field.clean(payload).image : A Pillow Image object instance JSON example { \"title\" : \"Unknown pleasures\" , \"cover\" : \"data:image/png;base64,SGVsbG8sIFdvcmxkIQ==\" } Python representation from django_api_forms import Form , ImageField from django.conf import settings from django.forms import fields class AlbumForm ( Form ): title = fields . CharField ( required = True , max_length = 100 ) cover = ImageField ( max_length = settings . DATA_UPLOAD_MAX_MEMORY_SIZE , mime = [ 'image/png' ])","title":"ImageField"},{"location":"install/","text":"Installation \u00b6 Library is published on PyPi index as django-api-forms . You can add it to your project using your favourite package manager. Few examples: # Using pip pip install django-api-forms # Using poetry peotry add django-api-forms # Using pipenv pipenv install django-api-forms # Using setup.py python setup.py install Extra functionality \u00b6 If you want to use some extra functionality, you have to install additional dependencies. msgpack \u00b6 Library checks for application/x-msgpack HTTP content type. To work it properly you have to install msgpack . We support extras_require , so you can do it by executing pip install django-api-forms[msgpack] while installing django-api-forms or individually by pip install msgpack inside your environment. Pillow \u00b6 Library provides FileField and ImageField , which are pretty similar to Django native implementation . There fields require Pillow to be installed inside of your environment. pip install django-api-forms[Pillow] pip install Pillow Fun fact \u00b6 You can install all extra dependencies using one call pip install django-api-forms[Pillow,msgpack] .","title":"Installation"},{"location":"install/#installation","text":"Library is published on PyPi index as django-api-forms . You can add it to your project using your favourite package manager. Few examples: # Using pip pip install django-api-forms # Using poetry peotry add django-api-forms # Using pipenv pipenv install django-api-forms # Using setup.py python setup.py install","title":"Installation"},{"location":"install/#extra-functionality","text":"If you want to use some extra functionality, you have to install additional dependencies.","title":"Extra functionality"},{"location":"install/#msgpack","text":"Library checks for application/x-msgpack HTTP content type. To work it properly you have to install msgpack . We support extras_require , so you can do it by executing pip install django-api-forms[msgpack] while installing django-api-forms or individually by pip install msgpack inside your environment.","title":"msgpack"},{"location":"install/#pillow","text":"Library provides FileField and ImageField , which are pretty similar to Django native implementation . There fields require Pillow to be installed inside of your environment. pip install django-api-forms[Pillow] pip install Pillow","title":"Pillow"},{"location":"install/#fun-fact","text":"You can install all extra dependencies using one call pip install django-api-forms[Pillow,msgpack] .","title":"Fun fact"},{"location":"tutorial/","text":"Tutorial \u00b6 This library helps you to handle basic RESTful API use-cases with Django Forms fashion. Library kinda replaces django.forms.Form with django_api_forms.Form and introduces few extra fields (boolean handling, BASE64 images/files, nesting). django_api_forms.Form defines format of the request and help you with: payload parsing (according to the Content-Type HTTP header) data validation and normalisation (using Django validators or custom clean_ method) BASE64 file/image upload construction of the basic validation response filling objects attributes (if possible, see exceptions) using setattr function (super handy for Django database models) Construction \u00b6 You can create form objects using class method Form.create_from_request(request: Request) -> Form which creates form instance from Django requests using appropriate parser from Content-Type HTTP header. from tests.testapp.forms import AlbumForm def my_view ( request ): form = AlbumForm . create_from_request ( request ) Currently, supports: JSON msgpack (requires msgpack package) TODO : Add possibility to have custom parsers (or override them) During construction Form.dirty: List[str] property is populated with property keys presented in obtained payload (sluts!!). Validation and normalisation \u00b6 This process is much more simple than in classic Django form. It consists of: Iterating over form attributes: calling Field.clean(value) method calling Form.clean_<field_name> method calling Form.add_error(field_name, error) in case of failures in clean methods if field is marked as dirty, normalized attribute is saved to Form.clean_data property Calling Form.clean method which returns final normalized values which will be presented in Form.clean_data (feel free to override it, by default does nothing, useful for conditional validation, you can still add errors u sing Form.add_error() ) Normalized data are available in Form.clean_data property (keys suppose to correspond with values from Form.dirty ). Validation errors are presented for each field in Form.errors: Dictionary[str, List[ValidationError]] property after Form.is_valid() method is called. As was mentioned above, you can extend property validation or normalisation by creating form method like clean_<property_name> . You can add additional ValidationError objects using Form.add_error(field: str, error: ValidationError) method. Result is final normalised value of the attribute. from django.forms import fields from django.core.exceptions import ValidationError from django_api_forms import Form class BookForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () def clean_title ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" : self . add_error ( 'title' , ValidationError ( \"Too cool!\" , code = 'too-cool' )) return self . cleaned_data [ 'title' ] . upper () def clean ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" and self . cleaned_data [ 'year' ] < 1979 : # Non field validation errors are present under key `__all__` in Form.errors property self . add_error ( None , ValidationError ( \"Is it you Doctor?\" , code = 'time-travelling' )) # Last chance to do some touchy touchy with self.clean_data return self . cleaned_data Nesting \u00b6 Database relationships \u00b6 Fill method \u00b6 IMPORTANT : Form fields FormField , FormFieldList , FileField and ImageField doesn't support this feature. You have to define fill_ method, if you want these fields populated. Form object method MyForm.fill(obj: Any, exclude: List[str] = None) which fills input obj using setattr according to the form fields. Only data present in clean_data property (data from request) will be populated. You can use it like this: from tests.testapp.forms import AlbumForm from tests.testapp.models import Album def my_view ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Raise validation error pass album = Album () form . fill ( album ) album . save () ModelChoiceField \u00b6 Field name is expected to have format like this: {field_name}(_{to_field_name})? so library is able to automatically resolve payload key postfix according to the to_field_name attribute. If there is no to_field_name provided, field name should be {field_name} or {field_name}_id . Normalised data are present in clean_data under key {field_name} (e.g. clean_data['{field_name}'] ). Few examples (normalized data are in clean_data['artist'] in all use-cases): from django.forms import ModelChoiceField from django_api_forms import Form from tests.testapp.models import Artist class MyFormNoPostfix ( Form ): artist = ModelChoiceField ( queryset = Artist . objects . all ()) class MyFormFieldName ( Form ): artist_name = ModelChoiceField ( queryset = Artist . objects . all (), to_field_name = 'name' ) class MyFormWithId ( Form ): artist_id = ModelChoiceField ( queryset = Artist . objects . all ()) Customization \u00b6 If you want to override default filling behaviour, you can define custom fill_{field} method inside your form class: from django.forms import fields from django_api_forms import Form , FormField , EnumField , DictionaryField from tests.testapp.models import Album , Artist from tests.testapp.forms import ArtistForm class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) type = EnumField ( enum = Album . AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def fill_year ( self , obj , value : int ) -> int : return 2020 def fill_artist ( self , obj , value : dict ) -> Artist : artist = Artist . objects . get_or_create ( name = value [ 'name' ] ) artist . genres = value [ 'genres' ] artist . members = value [ 'members' ] artist . save () return artist File uploads \u00b6","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This library helps you to handle basic RESTful API use-cases with Django Forms fashion. Library kinda replaces django.forms.Form with django_api_forms.Form and introduces few extra fields (boolean handling, BASE64 images/files, nesting). django_api_forms.Form defines format of the request and help you with: payload parsing (according to the Content-Type HTTP header) data validation and normalisation (using Django validators or custom clean_ method) BASE64 file/image upload construction of the basic validation response filling objects attributes (if possible, see exceptions) using setattr function (super handy for Django database models)","title":"Tutorial"},{"location":"tutorial/#construction","text":"You can create form objects using class method Form.create_from_request(request: Request) -> Form which creates form instance from Django requests using appropriate parser from Content-Type HTTP header. from tests.testapp.forms import AlbumForm def my_view ( request ): form = AlbumForm . create_from_request ( request ) Currently, supports: JSON msgpack (requires msgpack package) TODO : Add possibility to have custom parsers (or override them) During construction Form.dirty: List[str] property is populated with property keys presented in obtained payload (sluts!!).","title":"Construction"},{"location":"tutorial/#validation-and-normalisation","text":"This process is much more simple than in classic Django form. It consists of: Iterating over form attributes: calling Field.clean(value) method calling Form.clean_<field_name> method calling Form.add_error(field_name, error) in case of failures in clean methods if field is marked as dirty, normalized attribute is saved to Form.clean_data property Calling Form.clean method which returns final normalized values which will be presented in Form.clean_data (feel free to override it, by default does nothing, useful for conditional validation, you can still add errors u sing Form.add_error() ) Normalized data are available in Form.clean_data property (keys suppose to correspond with values from Form.dirty ). Validation errors are presented for each field in Form.errors: Dictionary[str, List[ValidationError]] property after Form.is_valid() method is called. As was mentioned above, you can extend property validation or normalisation by creating form method like clean_<property_name> . You can add additional ValidationError objects using Form.add_error(field: str, error: ValidationError) method. Result is final normalised value of the attribute. from django.forms import fields from django.core.exceptions import ValidationError from django_api_forms import Form class BookForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () def clean_title ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" : self . add_error ( 'title' , ValidationError ( \"Too cool!\" , code = 'too-cool' )) return self . cleaned_data [ 'title' ] . upper () def clean ( self ): if self . cleaned_data [ 'title' ] == \"The Hitchhiker's Guide to the Galaxy\" and self . cleaned_data [ 'year' ] < 1979 : # Non field validation errors are present under key `__all__` in Form.errors property self . add_error ( None , ValidationError ( \"Is it you Doctor?\" , code = 'time-travelling' )) # Last chance to do some touchy touchy with self.clean_data return self . cleaned_data","title":"Validation and normalisation"},{"location":"tutorial/#nesting","text":"","title":"Nesting"},{"location":"tutorial/#database-relationships","text":"","title":"Database relationships"},{"location":"tutorial/#fill-method","text":"IMPORTANT : Form fields FormField , FormFieldList , FileField and ImageField doesn't support this feature. You have to define fill_ method, if you want these fields populated. Form object method MyForm.fill(obj: Any, exclude: List[str] = None) which fills input obj using setattr according to the form fields. Only data present in clean_data property (data from request) will be populated. You can use it like this: from tests.testapp.forms import AlbumForm from tests.testapp.models import Album def my_view ( request ): form = AlbumForm . create_from_request ( request ) if not form . is_valid (): # Raise validation error pass album = Album () form . fill ( album ) album . save ()","title":"Fill method"},{"location":"tutorial/#modelchoicefield","text":"Field name is expected to have format like this: {field_name}(_{to_field_name})? so library is able to automatically resolve payload key postfix according to the to_field_name attribute. If there is no to_field_name provided, field name should be {field_name} or {field_name}_id . Normalised data are present in clean_data under key {field_name} (e.g. clean_data['{field_name}'] ). Few examples (normalized data are in clean_data['artist'] in all use-cases): from django.forms import ModelChoiceField from django_api_forms import Form from tests.testapp.models import Artist class MyFormNoPostfix ( Form ): artist = ModelChoiceField ( queryset = Artist . objects . all ()) class MyFormFieldName ( Form ): artist_name = ModelChoiceField ( queryset = Artist . objects . all (), to_field_name = 'name' ) class MyFormWithId ( Form ): artist_id = ModelChoiceField ( queryset = Artist . objects . all ())","title":"ModelChoiceField"},{"location":"tutorial/#customization","text":"If you want to override default filling behaviour, you can define custom fill_{field} method inside your form class: from django.forms import fields from django_api_forms import Form , FormField , EnumField , DictionaryField from tests.testapp.models import Album , Artist from tests.testapp.forms import ArtistForm class AlbumForm ( Form ): title = fields . CharField ( max_length = 100 ) year = fields . IntegerField () artist = FormField ( form = ArtistForm ) type = EnumField ( enum = Album . AlbumType , required = True ) metadata = DictionaryField ( fields . DateTimeField ()) def fill_year ( self , obj , value : int ) -> int : return 2020 def fill_artist ( self , obj , value : dict ) -> Artist : artist = Artist . objects . get_or_create ( name = value [ 'name' ] ) artist . genres = value [ 'genres' ] artist . members = value [ 'members' ] artist . save () return artist","title":"Customization"},{"location":"tutorial/#file-uploads","text":"","title":"File uploads"}]}